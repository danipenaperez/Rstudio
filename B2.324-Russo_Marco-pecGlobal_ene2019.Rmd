---
title: 'UOC - Mineria de datos: PEC Global'
author: "Autor: Russo Marco"
date: "Enero 2019"
output:
  html_document:
    includes:
      in_header: B2.324-PEC-header.html
    number_sections: yes
    theme: spacelab
    toc: yes
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
editor_options: 
  chunk_output_type: inline
---


****
# Introducción
****

En esta PEC trabajaremos con un dataset extraído de UCI - Machine Learning Repository sobre consumo de combustible de coches (en mpg). El dataset se llama “auto-mpg.txt” y consta de 9 variables:
1. mpg: v. continua
2. cilindros: v. discreta
3. cilindrada: v. continua
4. caballo de vapor (CV): v. continua
5. peso: v. continua
6. aceleración: v. continua
7. año del modelo: v. discreta
8. origen: v. discreta
9. nombre del coche (o ID): factor (único)


****
# Carga de datos
Cargad el fichero de datos e inspeccionar los tipos de variables. En el caso de que alguna variable no sea del tipo adecuado, aplicad la transformación necesaria. Pista: si una variable que debiese ser de tipo numérico tiene otro tipo es posible que no hayamos identificado bien los missings.

****

```{r,eval=TRUE,echo=TRUE}
## Carga del archivo auto-mpg con cabecera y asignamos una nueva variable al dataframe con autompg
nombreruta_PEC <- paste(getwd(),"/auto-mpg.txt")
autompg <- read.table(file = "auto-mpg.txt", header = TRUE, stringsAsFactors = FALSE, encoding="UTF-8", na.strings="NA")
```


```{r,eval=TRUE,echo=TRUE}
## Observaciones del archivo

dim(autompg)

# comprobamos los 10 primeros resultads, los últimos, y su estructura
nrow(autompg)
ncol(autompg)
head(autompg, n= 10)
tail(autompg, n = 10)

# visualizamos su estructura
str(autompg)
```

> El dataframe autompg contiene 398 observaciones y 9 variables. Me llama la atención la variable CV que contiene valores en formato __character__ con lo cuál se procederá a su transformación a valores númericos

```{r,eval=TRUE,echo=TRUE}
## Conversión de string a númerico
table(autompg$CV) #con table se observan además 6 valores inválidos
autompg$CV <- as.numeric(autompg$CV) # transformamos los valores del tipo char en númericos asignando a la nueva variable CV
table(autompg$CV)
str(autompg)

## Los 6 valores inválidos están configurados por defecto como NA y serán excluidos para análisis posteriores
```

****
# Análisis descriptivo
Obtened el número de filas y columnas. Para las variables numéricas describid los valores que toman (media, mediana, cuartiles,...). Podéis usar gráficos para complementar el análisis. Finalmente, anotad el número de missings para cada variable.
****

```{r,eval=TRUE,echo=TRUE}
summary(autompg) # visualizamos el fichero con summary
```

> CHECK 


> La variable __cilindrada__ está expresada en plgs (o pulgada cúbica, unidad de volumen que equivale al volumen de un cubo de una pulgada de lado)


> La variable __origen__ del tipo númerica tendría que apartenecer a un determinado continente o país por este motivo se tratará como factor creando otra columna


```{r,eval=TRUE,echo=TRUE}
# Comprobación de los países o continentes de la variable origen = 1
head(subset(autompg, subset = autompg$origen == 1))
```

> Para la variable *origen* = 1 por las marcas de los coches (chevrolet, ford, buick), tendrá que ser USA o North America

```{r,eval=TRUE,echo=TRUE}
# Comprobación de los países o continentes de la variable origen = 2
head(subset(autompg, subset = autompg$origen == 2))
```

> Para la variable *origen* = 2 por las marcas de los coches (vw, bmw, audi, peugeot) tendrá que ser Europa

```{r,eval=TRUE,echo=TRUE}
# Comprobación de los países o continentes de la variable origen = 3
head(subset(autompg, subset = autompg$origen == 3))
```

> Para la variable *origen* = 3 por las marcas de los coches (toyota, datsun) tendrá que ser Asia

```{r,eval=TRUE,echo=TRUE}
# Creamos un vector con los 3 continentes
continente <- c("NorthAmerica", "Europa", "Asia")
autompg$continente <- as.factor(autompg$origen)

# Convertimos el vector en factor y los añadimos al dataset original
levels(autompg$continente)[levels(autompg$continente) == 1] <- continente[1]
levels(autompg$continente)[levels(autompg$continente) == 2] <- continente[2]
levels(autompg$continente)[levels(autompg$continente) == 3] <- continente[3]
levels(autompg$continente)
str(autompg)
```


```{r,eval=TRUE,echo=TRUE}
## Visualización de las variables a través de boxplot
attach(autompg)
colnames(autompg)
head(subset(autompg$ID, subset = autompg$origen == 1))

# Boxplot de las variables mpg por año y origen (continente)
boxplot(mpg ~ año, data = autompg, 
        main = "MPG",
        col = "lightgray", border = "darkred", range = 100,
        outline = TRUE) 

boxplot(mpg ~ continente, data = autompg, 
        main = "MPG",
        col = "lightgray", border = "darkred", range = 100,
        outline = TRUE)  
    
# Boxplot de las variables cilindros por año y origen
boxplot(cilindros ~ año, data = autompg, 
        main = "cilindros",
        col = "lightgray", border = "darkred", range = 100)

boxplot(cilindros ~ continente, data = autompg, 
        main = "cilindros",
        col = "lightgray", border = "darkred", range = 100)


# Boxplot de las variables cilindrada por año y origen
boxplot(cilindrada ~ año, data = autompg, 
        main = "cilindrada",
        col = "lightgray", border = "darkred", range = 100)

boxplot(cilindrada ~ continente, data = autompg, 
        main = "cilindrada",
        col = "lightgray", border = "darkred", range = 100)


# Boxplot de las variables CV por año y origen
boxplot(CV ~ año, data = autompg, 
        main = "CV",
        col = "lightgray", border = "darkred", range = 100)

boxplot(CV ~ continente, data = autompg, 
        main = "CV",
        col = "lightgray", border = "darkred", range = 100)


# Boxplot de las variables cilindrada por año y origen
boxplot(peso ~ año, data = autompg, 
        main = "peso",
        col = "lightgray", border = "darkred", range = 100)

boxplot(peso ~ continente, data = autompg, 
        main = "peso",
        col = "lightgray", border = "darkred", range = 100)


boxplot(aceleración, data = autompg, 
        main = "aceleración",
        col = "lightgray", border = "darkred", range = 100)

boxplot(año, data = autompg, 
        main = "año",
        col = "lightgray", border = "darkred", range = 100)

boxplot(origen, data = autompg, 
        main = "origen",
        col = "lightgray", border = "darkred", range = 100)

#hist(autompg, )

```

> Visualizaremos la distribución de la variable __cilindros__

```{r,eval=TRUE,echo=TRUE}
table(cilindros)
hist(cilindros,
     main="Distribución Cilindros",
     xlab="Cilindros", ylab="Frecuencia",
     col="#9dbbae", border = "black",
     ylim =c(0,200))
```

> Visualizaremos la distribución de la variable ___cilindrada__

```{r,eval=TRUE,echo=TRUE}
table(cilindrada)
hist(cilindrada,
     main="Distribución Cilindrada",
     xlab="Cilindrada", ylab="Frecuencia",
     col="#9dbbae", border = "black",
     ylim =c(0,200))
```

> Visualizaremos la distribución de la variable **CV**

```{r,eval=TRUE,echo=TRUE}
table(CV)
hist(CV,
     main="Distribución CV",
     xlab="CV", ylab="Frecuencia",
     col="#9dbbae", border = "black",
     ylim =c(0,130) , xlim = c(40,230))
```

> Visualizaremos la distribución de la variable **Peso**

```{r,eval=TRUE,echo=TRUE}
table(peso)
hist(peso,
     main="Distribución Peso",
     xlab="Peso", ylab="Frecuencia",
     col="#9dbbae", border = "black")
```

> Visualizaremos la distribución de la variable **Aceleración**

```{r,eval=TRUE,echo=TRUE}
table(aceleración)
hist(aceleración,
     main="Distribución Aceleración",
     xlab="Aceleración", ylab="Frecuencia",
     col="#9dbbae", border = "black")
```

> Visualizaremos la distribución de la variable **Año**

```{r,eval=TRUE,echo=TRUE}
table(año)
hist(año,
     main="Distribución Año",
     xlab="Año", ylab="Frecuencia",
     col="#9dbbae", border = "black", xlim = c(70,82))
```

```{r,eval=TRUE,echo=TRUE}
## Verificamos los valores nulos
table(is.na(autompg))

# Suma la cantidad de nulos
sum(is.na(autompg))

# Se eliminan los registros con datos nulos
autompg = na.omit(autompg)

# Comprobamos nuevamente los valores nulos
sum(is.na(autompg))

```

```{r,eval=TRUE,echo=TRUE}
#describe(autompg)
```




****
# Outliers
Investigad si existen outliers en las variables numéricas. En caso de detectar outliers, eliminadlos del dataset. Nota: debéis escribir un código R automático (es decir, evitar la inspección y la eliminación manual).
****

```{r,eval=TRUE,echo=TRUE}
par(mfrow=c(1, 2))
plot(autompg$mpg, autompg$cilindrada, xlim=c(0, 28), ylim=c(0, 230), main="With Outliers", xlab="speed", ylab="dist", pch="*", col="red", cex=2)
abline(lm(cilindrada ~ mpg, data=autompg), col="blue", lwd=3, lty=2)
```





****
# Intervalo de confianza
Calculad el IC al 97 % de mpg.
Nota: Se deben realizar los cálculos manualmente. No se pueden usar funciones R que ya calculen el IC
directamente (t.test o similar). Sí que podéis usar funciones como qnorm, pnorm, qt y pt.
****

```{r,eval=TRUE,echo=TRUE}
## Para mejor lectura de los rangos de valores entre las variables numéricas, efectuaremos una normalización de los datos creando un dataset, autompg.z
autompg.z <- autompg

# Verificamos si existen valores nulos
sum(is.na(autompg.z))

# Realizamos las normalización de las variables numéricas a excepción de origen y año, estos últimos los trataremos como categorícas.
autompg.z$mpg <- scale(autompg.z$mpg, scale = TRUE, center = TRUE)
autompg.z$cilindros <- scale(autompg.z$cilindros, scale = TRUE, center = TRUE)
autompg.z$cilindrada <- scale(autompg.z$cilindrada, scale = TRUE, center = TRUE)
autompg.z$CV <- scale(autompg.z$CV, scale = TRUE, center = TRUE)
autompg.z$ peso <- scale(autompg.z$peso, scale = TRUE, center = TRUE)
autompg.z$'aceleración' <- scale(autompg.z$'aceleración', scale = TRUE, center = TRUE)


# verificamos los 10 primeros resultados
head(autompg.z, n=10)
```




```{r,eval=TRUE,echo=TRUE}
# calculamos la media de la variable mpg
mpgAvg <- mean(autompg$mpg)

# calculamos la desviación estandar
mpgSd <- sd(autompg$mpg)

# calculamos el tamaño de la muestra
n <- dim(autompg)[1]

# Calculo IC 97%
alpha <- 1-0.97

# Error típico
errorTipico <- mpgSd / sqrt(n)

# Valor z
z <- qnorm(1- alpha/2)

# Margen de error
error <- z * errorTipico

# Límites del intervalo
lim <- mpgAvg + c(-1,1) * error
lim


table(mpgAvg, mpgSd, errorTipico, z, error, lim[1], lim[2])
```

## Comprobación con T-student

```{r,eval=TRUE,echo=TRUE}
t.test(x = mpg, conf.level = 0.97)
```

> Intepretación



****
# Contraste de hipótesis
Un político afirma que el valor esperado de mpg es, como mínimo, de 25 unidades. Basándonos en nuestros datos, ¿podemos rechazar esta afirmación con un nivel de confianza del 95%?
Nota: Se deben realizar los cálculos manualmente. No se pueden usar funciones R que ya calculen el IC directamente (t.test o similar). Sí que podéis usar funciones como qnorm, pnorm, qt y pt.
a) Escribid el contraste a realizar.
b) Calculad el estadístico de contraste, el valor crítico y el p-valor.
c) Interpretad el resultado.
****

H0 > 25
H1 <= 25


```{r,eval=TRUE,echo=TRUE}
# Región de aceptación de la hipótesis nula
alpha <- 0.05
valorCritico <- qt(alpha, df = n-1)
valorCritico
```


```{r,eval=TRUE,echo=TRUE}

# Ya tenemos calculado la media y la sd de la variable MPG
mpgAvg
mpgSd

# Estadístico de contraste
estadistico <- (mpgAvg - 25) / (mpgSd/sqrt(25))
estadistico
```


```{r,eval=TRUE,echo=TRUE}
# Cálculo del valor p asociado a este contraste de hipótesis 
p <- pt(estadistico, df = n-1, lower.tail = TRUE)
p
```


> # Interpretación: Como el valor del estadístico de contraste es inferior al valor crítico se rechaza la hipótesis nula.
> # Interpretación: Como el valor p no es superior a 0.10, se rechaza la hipótesis nula.


****
# Correlación
a) Obtened las correlaciones entre variables numéricas. Nota: podéis tener problemas por los missings. Usad: ?cor/help(cor) para obtener ayuda y encontrar una solución.
b) Mostrad las correlaciones con un gráfico. Pista: una opción interesante es usar la librería “corrplot”.
c) Interpretad el resultado del apartado anterior.
****


```{r,eval=TRUE,echo=TRUE}
cor(autompg.z[1:6])# correlación de las 6 variables númericas excepto el de origen y año
plot(autompg.z[1:6])

#install.packages("corrplot")
library(corrplot)
#dfa_pca_mat <- matrix(as.numeric(unlist(df_pca)),nrow=nrow(df_pca))
#colnames(dfa_pca_mat) <- colnames(df_pca)
corrplot(cor(autompg.z[1:6]), is.corr = FALSE, method = "color")
corrplot(cor(autompg.z[1:6]), is.corr = FALSE, method = "square")

# Añadimos la columna de año en este gráfico
corrplot(cor(autompg.z[1:7]), is.corr = FALSE, method = "number")
```


> Una correlación positiva está representada en azul , mientras la correlación negativa en rojo. La intensidad del color y la forma del “símbolo” es proporcional al coeficiente de correlación

> Podemos observar como *cilindros* tiene una correlación positiva con **cilindrada**, **CV** y **peso**, respectivamente 0.95, 0.84 y 0.90

> La cilindrada incide sobre el **peso**, así como a más cilindrada, más **CV** y más **cilindros**.

> La variable *aceleración* incide en el consumo, así que tiene su relación con *mpg*. 

> Referente a la variable *año*, tiene una relación con consumo **mpg** y sobre la **aceleración** aunque si mínima.







****
# Regresión lineal
a) Estimad un modelo que explique la variable mpg en función de cilindrada, aceleración, año, y origen.
b) Interpretad el resultado del modelo, indicando si los coeficientes son estadísticamente significativos.
c) Predecid el valor para una nueva observación: coche de cilindrada 145, aceleración 15.50, año 76 y origen 2.
****

```{r,eval=TRUE,echo=TRUE}
attach(autompg.z)
par(mfrow = c(2, 2))
fit <- lm(mpg ~ cilindrada + aceleración + año + origen, data = autompg.z)
plot(fit)
anova(fit)
```

```{r,eval=TRUE,echo=TRUE}
head(summary(lm(mpg ~ . , data = autompg.z[1:7]))$coefficients, n=10)

summary(lm(mpg ~ cilindrada , data = autompg.z))$coefficients

summary(lm(mpg ~ aceleración , data = autompg.z))$coefficients

summary(lm(mpg ~ año , data = autompg.z))$coefficients

summary(lm(mpg ~ origen , data = autompg.z))$coefficients
```


```{r,eval=TRUE,echo=TRUE}
t(coefficients(fit))
```


****
# ANOVA
a) Realizad grupos para la variable año. 
G1: año < 73
G2: 73<=año<76
G3: 76<=año<79
G4: año > 79
b) Aplicad ANOVA para identificar si existen diferencias en mpg entre los grupos creados. Interpretad el resultado.
c) Explicad el significado de los cálculos SSW, SSB y SST de un análisis de varianza. ¿Cómo se usan estos cálculos para investigar si hay diferencias entre los grupos?
d) En el caso de que se detecten diferencias significativas entre las medias de los distintos grupos, calculad un test a posteriori (post-hoc test) como el test de Tukey. Interpretad el resultado.
****


```{r,eval=TRUE,echo=TRUE}
## Crearemos los 4 diferentes grupos por año
#colnames(autompg)
#table(autompg$año)
#str(autompg)
library(plyr)
library(dplyr)
# creamos una copia del dataset original, autompg.anova
autompg.aov <- data.frame(Año = autompg$año, MPG = autompg$mpg)
head(autompg.aov)

aggregate(autompg.aov$MPG ~ autompg.aov$Año, data = subset(autompg.aov, subset= autompg.aov$Año < 73), FUN = mean)




# Creación del grupo G1 con filtro
g1 <- autompg.aov %>%
  filter(autompg.aov$Año < 73)
g1 <- round(aggregate(MPG ~ Año, data = g1, FUN = mean), digits = 2)

# Creación del grupo G2 con filtro
g2 <- autompg.aov %>%
  filter(autompg.aov$Año >= 73 & autompg.aov$Año < 76)
g2 <- round(aggregate(MPG ~ Año, data = g2, FUN = mean), digits = 2)

# Creación del grupo G3 con filtro
g3 <- autompg.aov %>%
  filter(autompg.aov$Año >= 76 & autompg.aov$Año < 79)
g3 <- round(aggregate(MPG ~ Año, data = g3, FUN = mean), digits = 2)

# Creación del grupo G4 con filtro
g4 <- autompg.aov %>%
  filter(autompg.aov$Año >= 79)
g4 <- round(aggregate(MPG ~ Año, data = g4, FUN = mean), digits = 2)


# Otra alternativa sería convertir en medias MPG directamente y aplicar posteriormente los grupos
# aggregate(autompg.aov$MPG ~ autompg.aov$Año, data = autompg.aov, FUN = mean)
# autompg.aov$avgMPG <- autompg.aov$MPG(round(ddply(autompg.aov, ~Año, summarise,mean=mean(MPG))), digits=2)

```


```{r,eval=TRUE,echo=TRUE}
## Aplicamos ANOVA
g1$Año <- as.character(g1$Año)
g2$Año <- as.character(g2$Año)
g3$Año <- as.character(g3$Año)
g4$Año <- as.character(g4$Año)

X <- rbind(g1$MPG,g2$MPG,g3$MPG,g4$MPG, stringsAsFactors = FALSE)
boxplot(X)

# representamos grafícamente los 4 grupos
group <- c("<73","73<76","76<79",">79")
valor <- c(g1,g2,g3,g4)
df <- data.frame(group,valor)
boxplot(valor)
```

```{r,eval=TRUE,echo=TRUE}
# Calculo AOV
myaov <- aov()


```

